### Сравнение трёх подходов к параллельным вычислениям: `asyncio`, `multiprocessing` и `threading`

#### 1. **Асинхронное программирование с `asyncio`**

```python
async def calculate_sum(start, end):
    return sum(range(start, end))


async def main(tasks_count, start, end):
    tasks = []
    for i in range(tasks_count):
        tasks.append(
            asyncio.create_task(
                calculate_sum(
                    start + i * (end - start + 1) // tasks_count,
                    start + (i + 1) * (end - start + 1) // tasks_count
                )
            )
        )
    result = sum(await asyncio.gather(*tasks))
    return result
```

Асинхронный подход с использованием `asyncio` позволяет выполнять задачи без блокировки основного потока. Он особенно
эффективен при наличии задач, которые зависят от операций ввода-вывода (например, сетевые запросы). В случае интенсивных
вычислений, как в этом примере, асинхронность не даёт существенного выигрыша, так как задачи не связаны с I/O.

**Преимущества `asyncio`:**

- Эффективное управление операциями ввода-вывода.
- Подходит для веб-сервисов и обработки сетевых запросов.
- Относительно простая реализация и управление задачами.

**Недостатки:**

- Меньше подходит для задач, требующих больших вычислений (CPU-bound), так как все задачи выполняются в одном потоке.
- Не использует все доступные ядра процессора, что может ограничить производительность на многоядерных системах.

**Применение:**

- Наилучший выбор для I/O-bound задач, например, работы с сетевыми соединениями, запросами к базам данных.

#### 2. **Многопроцессное программирование с `multiprocessing`**

```python
def calculate_sum(start, end):
    return sum(range(start, end))


def main(tasks_count, start, end):
    results = multiprocessing.Manager().list([0] * tasks_count)
    tasks = []
    for i in range(tasks_count):
        tasks.append(
            multiprocessing.Process(
                target=calculate_sum,
                args=(start + i * (end - start + 1) // tasks_count, start + (i + 1) * (end - start + 1) // tasks_count)
            )
        )
    for i in tasks:
        i.start()
    for i in tasks:
        i.join()
    result = sum(results)
    return result
```

Модуль `multiprocessing` создаёт отдельные процессы для выполнения задач. Это даёт возможность распределять вычисления по
нескольким ядрам процессора, что повышает производительность для задач, нагружающих CPU.

**Преимущества `multiprocessing`:**

- Полноценное использование всех ядер процессора, что делает его подходящим для CPU-bound задач.
- Процессы изолированы друг от друга, что позволяет избежать некоторых проблем с доступом к общим данным (например, гонки
  потоков).

**Недостатки:**

- Создание процессов может занимать больше времени и памяти, чем потоки.
- Передача данных между процессами через `multiprocessing.Manager` может быть медленной.
- Код сложнее, особенно при передаче данных между процессами.

**Применение:**

- Подходит для вычислительно интенсивных задач (CPU-bound), например, математических вычислений, рендеринга или работы с
  большими массивами данных.

#### 3. **Многопоточное программирование с `threading`**

```python
def calculate_sum(start, end):
    return sum(range(start, end))


def main(tasks_count, start, end):
    results = [0] * tasks_count
    tasks = []
    for i in range(tasks_count):
        tasks.append(
            threading.Thread(
                target=calculate_sum,
                args=(start + i * (end - start + 1) // tasks_count, start + (i + 1) * (end - start + 1) // tasks_count)
            )
        )
    for i in tasks:
        i.start()
    for i in tasks:
        i.join()
    result = sum(results)
    return result
```

Многопоточное программирование использует потоки для параллельного выполнения задач. Потоки легче по сравнению с процессами, но
они работают в одном процессе и разделяют память. Это делает их более эффективными для задач, связанных с I/O,но менее
эффективными для CPU-bound задач, так как Python использует GIL (Global Interpreter Lock), что ограничивает истинный
параллелизм для задач, активно использующих процессор.

**Преимущества `threading`:**

- Легковесные потоки, которые запускаются быстрее, чем процессы.
- Подходит для I/O-bound задач, таких как работа с файлами, сетевыми запросами и ожидание ввода-вывода.

**Недостатки:**

- Из-за GIL потоки не могут эффективно использовать многопроцессорные системы для CPU-bound задач.
- Потоки разделяют память, что может приводить к проблемам с синхронизацией и гонкам данных.

**Применение:**

- Лучший выбор для задач, связанных с I/O, например, параллельная работа с файлами, загрузка данных с интернета и др.

### Сравнение подходов

| Подход                               | Асинхронное (`asyncio`)                    | Многопроцессное (`multiprocessing`)        | Многопоточное (`threading`)                         |
|--------------------------------------|--------------------------------------------|--------------------------------------------|-----------------------------------------------------|
| **Параллелизм**                      | Кооперативная многозадачность (один поток) | Истинный параллелизм (несколько процессов) | Псевдопараллелизм (несколько потоков, один процесс) |
| **Использование ядер CPU**           | Одно ядро                                  | Несколько ядер                             | Одно ядро                                           |
| **Подходит для**                     | I/O-bound задач                            | CPU-bound задач                            | I/O-bound задач                                     |
| **Проблемы с синхронизацией**        | Отсутствуют                                | Отсутствуют                                | Возможны гонки данных                               |
| **Сложность кода**                   | Средняя                                    | Высокая                                    | Низкая                                              |
| **Производительность для CPU-bound** | Низкая                                     | Высокая                                    | Низкая                                              |
| **Производительность для I/O-bound** | Высокая                                    | Низкая                                     | Высокая                                             |

### Выводы

- **`asyncio`** — лучший выбор для I/O-bound задач, таких как сетевые запросы и взаимодействие с базами данных, где нужно
  обрабатывать множество асинхронных операций в одном потоке.
- **`multiprocessing`** — лучший выбор для CPU-bound задач, требующих максимального использования многопроцессорных систем.
- **`threading`** — эффективен для задач с интенсивным вводом-выводом, но не подходит для интенсивных вычислений из-за
  ограничений GIL.
