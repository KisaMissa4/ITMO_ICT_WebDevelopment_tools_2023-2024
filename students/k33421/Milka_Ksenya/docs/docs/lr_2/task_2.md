### Исследование трёх подходов к параллелизму: Асинхронность, Многопроцессность и Многопоточность для парсинга

### 1. **Асинхронность с использованием `asyncio`**

```python
async def iteration(page: int):
    content = await parse.async_get_content(page)
    data_list = parse.parse_data(content)
    for data in data_list:
        await database.async_insert_data_to_project(data)


async def main():
    tasks = [iteration(page) for page in range(1, 6)]
    start = time.perf_counter()
    await asyncio.gather(*tasks)
    end = time.perf_counter()
    print(f"Время: {end - start}")
```

Асинхронное программирование через `asyncio` работает в одном потоке, но позволяет запускать задачи параллельно, эффективно
управляя операциями ввода-вывода (I/O). Этот подход особенно эффективен для работы с сетевыми запросами или чтением файлов,
когда процессы блокируются на ожидании ответа.

**Результаты тестирования**:

- **Время выполнения: 5 секунд**.

#### Преимущества:

- Легковесный подход без создания дополнительных потоков или процессов.
- Хорошо подходит для I/O-bound задач.
- Простота в управлении большим числом асинхронных операций.

#### Недостатки:

- Для CPU-bound задач асинхронность менее эффективна, так как выполняется в одном потоке и не использует все доступные ядра
  CPU.
- При неправильно настроенных соединениях с базой данных производительность может значительно снижаться.

#### Вывод:

Асинхронность — это отличный выбор для задач, где много операций ввода-вывода (например, сетевые запросы). Однако для задач,
связанных с интенсивными вычислениями или массовой вставкой данных в базу данных, асинхронный подход может быть медленным.

### 2. **Многопроцессное программирование с использованием `multiprocessing`**

```python
def iteration(page: int):
    content = parse.get_content(page)
    data_list = parse.parse_data(content)
    for data in data_list:
        database.insert_data_to_project(data)


def main():
    tasks = [multiprocessing.Process(target=iteration, args=(page,)) for page in range(1, 6)]
    start = time.perf_counter()
    for task in tasks:
        task.start()
    for task in tasks:
        task.join()
    end = time.perf_counter()
    print(f"Время: {end - start}")
```

Многопроцессное программирование использует несколько процессов, каждый из которых выполняется независимо и параллельно. Это
позволяет полноценно использовать несколько ядер CPU, что делает этот подход идеальным для задач, нагружающих процессор (
CPU-bound).

**Результаты тестирования**:

- **Время выполнения: 2 секунды**.

#### Преимущества:

- Полное использование всех доступных ядер процессора.
- Эффективно для CPU-bound задач.
- Процессы изолированы друг от друга, что предотвращает проблемы с доступом к общей памяти.

#### Недостатки:

- Создание процессов требует больших затрат по времени и памяти, по сравнению с потоками или асинхронными задачами.
- Передача данных между процессами может быть медленной из-за необходимости межпроцессного взаимодействия.

#### Вывод:

Многопроцессный подход — лучший выбор для задач с интенсивными вычислениями (например, большие объёмы вычислений или массовая
обработка данных). Для задач, которые требуют обработки больших объёмов данных и загрузки процессора, этот подход даёт
значительный прирост производительности.

### 3. **Многопоточное программирование с использованием `threading`**

```python
def iteration(page: int):
    content = parse.get_content(page)
    data_list = parse.parse_data(content)
    for data in data_list:
        database.insert_data_to_project(data)


def main():
    tasks = [threading.Thread(target=iteration, args=(page,)) for page in range(1, 6)]
    start = time.perf_counter()
    for task in tasks:
        task.start()
    for task in tasks:
        task.join()
    end = time.perf_counter()
    print(f"Время: {end - start}")
```

Многопоточное программирование использует несколько потоков в одном процессе. Это может быть полезно для задач с интенсивным
вводом-выводом, но ограничено по производительности для вычислительно нагруженных задач (из-за наличия GIL — Global Interpreter
Lock).

**Результаты тестирования**:

- **Время выполнения: 1 секунда**.

#### Преимущества:

- Потоки легче и быстрее создаются по сравнению с процессами.
- Эффективно для I/O-bound задач (например, работы с файлами или сетевыми запросами).

#### Недостатки:

- GIL ограничивает использование нескольких потоков для CPU-bound задач, так как потоки не могут одновременно выполнять
  Python-код на разных ядрах процессора.
- В отличие от процессов, потоки имеют доступ к общей памяти, что может вызывать проблемы с синхронизацией.

#### Вывод:

Многопоточный подход работает быстрее для I/O-bound задач, но может не подойти для CPU-bound задач из-за GIL. Этот подход
эффективен для задач, связанных с вводом-выводом, где важна скорость выполнения отдельных операций.

### Общий вывод

| Подход                | Время выполнения | Подходит для | Преимущества                                 | Недостатки                               |
|-----------------------|------------------|--------------|----------------------------------------------|------------------------------------------|
| **`asyncio`**         | 5 секунд         | I/O-bound    | Легковесность, простота асинхронных операций | Плохо подходит для CPU-bound задач       |
| **`multiprocessing`** | 2 секунды        | CPU-bound    | Полное использование всех ядер CPU           | Высокие затраты на создание процессов    |
| **`threading`**       | 1 секунда        | I/O-bound    | Легкость создания потоков                    | Ограничено производительностью из-за GIL |

### Рекомендации:

- **`asyncio`**: Используйте для задач с интенсивным вводом-выводом, например, запросы к веб-сервисам или работу с базами
  данных.
- **`multiprocessing`**: Идеальный выбор для вычислительно интенсивных задач, таких как массовая обработка данных.
- **`threading`**: Подходит для задач с интенсивным вводом-выводом, но менее эффективен для задач, требующих много вычислений.
